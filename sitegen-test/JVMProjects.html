<!DOCTYPE html>
<html lang="en">

<!--
  Copyright 2014 Pants project contributors (see CONTRIBUTORS.md).
  Licensed under the Apache License, Version 2.0 (see LICENSE).
-->

<head>
  <meta charset="utf-8" />
  <title>JVM Projects with Pants</title>
  <link rel="stylesheet" href="s.css">
  <script src="s.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" href="logo.ico">
</head>

<body>

<div class="mainflow">
<nav class="breadcrumbs">
<ul>
<li><a href="index.html">Pants Build System</a>
<li><a href="JVMProjects.html">JVM Projects with Pants</a>
</ul>
</nav>

<nav class="pagetoc">
<ul>
<li class="toc-h1"><a href="#relevant-goals-and-targets">Relevant Goals and Targets</a></li>
<li class="toc-h1"><a href="#build-for-a-simple-binary">BUILD for a Simple Binary</a></li>
<li class="toc-h2"><a href="#depending-on-a-library">Depending on a Library</a></li>
<li class="toc-h2"><a href="#a-test-target">A Test Target</a></li>
<li class="toc-h2"><a href="#depending-on-a-jar">Depending on a Jar</a></li>
<li class="toc-h1"><a href="#the-usual-commands-jvm">The Usual Commands: JVM</a></li>
<li class="toc-h1"><a href="#toolchain">Toolchain</a></li>
<li class="toc-h1"><a href="#java7-vs-java6-which-java">Java7 vs Java6, Which Java</a></li>
<li class="toc-h1"><a href="#bundles-deploy-able-runnable-file-trees">Bundles: Deploy-able Runnable File Trees</a></li>
</ul>
</nav>

<!-- main content start -->
<body>
<!-- generated by pants! -->
<table class="h-plus-pilcrow"><tbody><tr><td><h1 id="jvm-projects-with-pants">JVM Projects with Pants</h1></td><td><div class="pilcrow-div"><a class="pilcrow-link" href="#jvm-projects-with-pants">¶</a></div></td></tr></tbody></table>
<!--
  Converted from src/python/pants/docs/JVMProjects.rst 2014/10/16
  TODO(lahosken): before new doc system "goes live", freshen this as needed.
-->
<p>Assuming you know the basic
<!-- TODO(lahosken) proper link -->
<a href="http://pantsbuild.github.io/first_concepts.html">Pants concepts</a> and have
gone through the
<!-- TODO(lahosken) proper link -->
<a href="http://pantsbuild.github.io/first_tutorial.html">first Tutorial</a>,
you've made a great start towards
using Pants to work with Java and Scala code. This page goes into some
of the details.</p>
<p>If you are accustomed to the Maven tool and contemplating moving to
Pants, you are not alone;
<!-- TODO(lahosken) proper link -->
<a href="http://pantsbuild.github.io/from_maven.html">Pants for Maven Experts</a>
has some advice.</p>
<table class="h-plus-pilcrow"><tbody><tr><td><h2 id="relevant-goals-and-targets">Relevant Goals and Targets</h2></td><td><div class="pilcrow-div"><a class="pilcrow-link" href="#relevant-goals-and-targets">¶</a></div></td></tr></tbody></table>
<p>When working with JVM languages, the following goals and targets are
especially relevant.</p>
<p><strong>Deployable Bundle</strong> <em>Runnable Binary, optionally with non-JVM files</em></p>
<blockquote>
<p>Deployable bundles are directories, optionally archived, that contain
all files necessary to run the application. The <code>bundle</code> goal is used
to create these deployable bundles from either <code>jvm_binary</code> or
<code>jvm_app</code> targets.</p>
<p>Bundling a <code>jvm_binary</code> target is appropriate when your application is
entirely jar-based; that is, it's entirely class files and resources
packaged inside the jars themselves. If your application requires
"extra stuff" (e.g.: start scripts, config files) use a <code>jvm_app</code>
which allows you to include files in the bundle directory that
supplement the binary jar and its dependencies. You can learn
more about <a href="JVMProjects.html#jvm_bundles" xref="jvm_bundles">bundles</a></p>
</blockquote>
<p><strong>Runnable Binary</strong></p>
<blockquote>
<p>On its own, a <code>jvm_binary</code> BUILD target describes an executable <code>.jar</code>
(something you can run with <code>java -jar</code>). The jar is described as
executable because it contains a manifest file that specifies the main
class as well as classpath for all dependencies. If your program
contains only jars (and resources packaged in those jars), this is all
you need to run the binary. Use <code>./pants goal binary</code> to compile its
code; <code>./pants goal run</code> to run it "in place".</p>
</blockquote>
<p><strong>Importable Code</strong></p>
<blockquote>
<p><code>java_library</code> BUILD targets make Java source code <code>import</code>-able. The
rule of thumb is that each directory of <code>.java</code> files has a <code>BUILD</code>
file with a <code>java_library</code> target. A JVM target that has a
<code>java_library</code> in its <code>dependencies</code> can import its code.
<code>scala_library</code> targets are similar, but compiled with Scala.</p>
<p>To use pre-built <code>.jar</code>s, a JVM target can depend on a <code>jar</code>, a
reference to published code; these <code>jar</code>s normally live in a
<!-- TODO(lahosken) proper link -->
directory called <a href="http://pantsbuild.github.io/3rdparty_jvm.html">3rdparty</a>.</p>
<p>Pants can <code>publish</code> a JVM library so code in other repos can use it;
if the <code>*_library</code> target has a <code>provides</code> parameter, that specifies
the repo/address at which to <a href="publish.html">publish</a>.</p>
<p>An <code>annotation_processor</code> BUILD target defines a Java library one
containing one or more annotation processors.</p>
</blockquote>
<p><strong>Tests</strong></p>
<blockquote>
<p>A <code>junit_tests</code> BUILD target holds source code for some JUnit tests;
typically, it would have one or more <code>java_library</code> targets as
dependencies and would import and test their code.</p>
<p>A <code>scala_specs</code> target is similar, but has source code for Scala
specs.</p>
<p>The Pants <code>test</code> goal runs tests.</p>
</blockquote>
<p><strong>Generated Code</strong></p>
<blockquote>
<p>A <code>java_thrift_library</code> generates Java code from <code>.thrift</code> source; a
JVM target that has this target in its <code>dependencies</code> can <code>import</code> the
generated Java code. A <code>java_protobuf_library</code> is similar, but
generates Java code from protobuffer source. A <code>jaxb_library</code>
definition generates code to read and write XML using an XML schema
(.xsd files).</p>
</blockquote>
<table class="h-plus-pilcrow"><tbody><tr><td><h2 id="build-for-a-simple-binary">BUILD for a Simple Binary</h2></td><td><div class="pilcrow-div"><a class="pilcrow-link" href="#build-for-a-simple-binary">¶</a></div></td></tr></tbody></table>
<p>The <a href="https://github.com/pantsbuild/pants/tree/master/examples/src/java/com/pants/examples/hello">Pants Build Java hello world
sample</a>
code shows the BUILD file for a simple Java binary (in the <code>main/</code>
directory):</p>
<p>
<pre>
jvm_binary(name = 'main-bin',
  dependencies = [
    'examples/src/java/com/pants/examples/hello/greet',
  ],
  resources=[
    'examples/src/resources/com/pants/example/hello',
  ],
  source = 'HelloMain.java',
  main = 'com.pants.examples.hello.main.HelloMain',
  basename = 'hello-example',
)
</pre>
</p>
<p>This small program has just two dependencies. One is a library, a
<code>java_library</code>, a compiled set of source code from this workspace. The
other is a "third party" dependency, a pre-compiled artifact whose
source lives somewhere outside the workspace.</p>
<table class="h-plus-pilcrow"><tbody><tr><td><h3 id="depending-on-a-library">Depending on a Library</h3></td><td><div class="pilcrow-div"><a class="pilcrow-link" href="#depending-on-a-library">¶</a></div></td></tr></tbody></table>
<p>The rule of thumb is that each directory of <code>.java</code> or <code>.scala</code> files
has a library target. If you find yourself thinking "we should move some
of this code to another directory," you probably also want to set up a
<code>BUILD</code> file with a <code>java_library</code> (or <code>scala_library</code>) target. Here we
see the library target which <code>main-bin</code> depends on. This library target
lives in <code>hello/greet/BUILD</code>:</p>
<p>
<pre>
java_library(name = 'greet',
  dependencies = [], # A more realistic example would depend on other libs,
                     # but this "hello world" is pretty simple.
  sources = globs('*.java'),
  provides = artifact(org='com.pants.examples',
                      name='hello-greet',
                      repo=public,),
)</pre>
</p>
<p>This library could depend on other build targets and artifacts; if your
code imports something, that implies a <code>BUILD</code> dependency.</p>
<table class="h-plus-pilcrow"><tbody><tr><td><h3 id="a-test-target">A Test Target</h3></td><td><div class="pilcrow-div"><a class="pilcrow-link" href="#a-test-target">¶</a></div></td></tr></tbody></table>
<p>The <a href="https://github.com/pantsbuild/pants/tree/master/examples/tests/java/com/pants/examples/hello">Pants Java Hello World example
tests</a>
are normal JUnit tests. To run them with Pants, we need a target for
them:</p>
<p>
<pre>
junit_tests(name='greet',
  sources=globs('*.java'),
  dependencies=[
    '3rdparty:junit',
    'examples/src/java/com/pants/examples/hello/greet',
  ],
  resources=[
    'examples/src/resources/com/pants/example/hello',
  ],
)</pre>
</p>
<p>As with other targets, this one depends on code that it imports. Thus, a
typical test target depends on the library that it tests.</p>
<table class="h-plus-pilcrow"><tbody><tr><td><h3 id="depending-on-a-jar">Depending on a Jar</h3></td><td><div class="pilcrow-div"><a class="pilcrow-link" href="#depending-on-a-jar">¶</a></div></td></tr></tbody></table>
<p>The test example depends on a jar, <code>junit</code>. Instead of compiling from
source, Pants invokes ivy to fetch such jars. To reduce the danger of
version conflicts, we use the 3rdparty idiom: we keep references to
these "third-party" jars together in <code>BUILD</code> files under the <code>3rdparty/</code>
directory. Thus, the test has a <code>3rdparty:</code> dependency:</p>
<p>
<pre>
junit_tests(name='greet',
  sources=globs('*.java'),
  dependencies=[
    '3rdparty:junit',
    'examples/src/java/com/pants/examples/hello/greet',
  ],
  resources=[
    'examples/src/resources/com/pants/example/hello',
  ],
)</pre>
</p>
<p>The <code>BUILD</code> files in <code>3rdparty/</code> have targets like:</p>
<div class="codehilite"><pre>jar_library(name='junit',
            jars = [
              jar(org='junit', name='junit-dep', rev='4.11').with_sources(),
            ],
            dependencies = [
              ':hamcrest-core',
            ],
           )
</pre></div>
<p>Those <a href="build_dictionary.html#bdict_jar" xref="bdict_jar">jar() things</a> are references to public jars.</p>
<table class="h-plus-pilcrow"><tbody><tr><td><h2 id="the-usual-commands-jvm">The Usual Commands: JVM</h2></td><td><div class="pilcrow-div"><a class="pilcrow-link" href="#the-usual-commands-jvm">¶</a></div></td></tr></tbody></table>
<p><strong>Make sure code compiles and tests pass:</strong><br/>
Use the <code>test</code> goal with the targets you're interested in. If they are
test targets, Pants runs the tests. If they aren't test targets, Pants
will still compile them since it knows it must compile before it can
test.</p>
<p><code>./pants goal test examples/src/java/com/pants/examples/hello/:: examples/tests/java/com/pants/examples/hello/::</code></p>
<p>Output from the test run is written to <code>.pants.d/test/junit/</code>; you can
see it on the console with <code>--no-test-junit-suppress-output</code>.</p>
<p><strong>Run just that one troublesome test class:</strong> (assuming a JUnit test;
other frameworks use other flags)</p>
<p><code>./pants goal test examples/tests/java/com/pants/examples/hello/:: --test-junit-test=com.pants.examples.hello.greet.GreetingTest</code></p>
<p><strong>Packaging Binaries</strong><br/>
To create a jar containing just the code built by a JVM target, use the
jar goal:</p>
<div class="codehilite"><pre>./pants goal jar examples/src/java/com/pants/examples/hello/greet
</pre></div>
<p>To create a <a href="JVMProjects.html#jvm_bundles" xref="jvm_bundles">bundle</a> (a runnable thing and its
dependencies, perhaps including helper files):</p>
<div class="codehilite"><pre>./pants goal bundle examples/src/java/com/pants/examples/hello/main --bundle-archive=zip
</pre></div>
<p>If your bundle is JVM, it's a zipfile which can run by means of an
<code>unzip</code> and setting your <code>CLASSPATH</code> to <code>$BASEDIR/my_service.jar</code> (where
<code>$BASEDIR is</code> the directory you've just unzipped).</p>
<p><strong>Get Help</strong></p>
<blockquote>
<p>Get basic help:</p>
<div class="codehilite"><pre>./pants goal help
</pre></div>
<p>Get a list of goals:</p>
<div class="codehilite"><pre>./pants goal goals
</pre></div>
<p>Get help for one goal:</p>
<div class="codehilite"><pre>./pants goal help onegoal
</pre></div>
</blockquote>
<table class="h-plus-pilcrow"><tbody><tr><td><h2 id="toolchain">Toolchain</h2></td><td><div class="pilcrow-div"><a class="pilcrow-link" href="#toolchain">¶</a></div></td></tr></tbody></table>
<p>Pants uses <a href="http://ant.apache.org/ivy/">Ivy</a> to resolve <code>jar</code>
dependencies. To change how Pants resolves these, use <code>--ivy-*</code>
command-line parameters along with <code>--resolve-*</code> parameters.</p>
<p>Pants uses <a href="https://github.com/martylamb/nailgun">Nailgun</a> to speed up
compiles. It's a JVM daemon that runs in the background; this saves time
for JVM startup and class loading.</p>
<p>Pants uses Jmake, a dependency tracking compiler facade.</p>
<table class="h-plus-pilcrow"><tbody><tr><td><h2 id="java7-vs-java6-which-java">Java7 vs Java6, Which Java</h2></td><td><div class="pilcrow-div"><a class="pilcrow-link" href="#java7-vs-java6-which-java">¶</a></div></td></tr></tbody></table>
<p>Pants uses the java on your <code>PATH</code> (not <code>JAVA_HOME</code>). To specify a
specific java version for just one pants invocation:</p>
<div class="codehilite"><pre>PATH=/usr/lib/jvm/java-1.7.0-openjdk7/bin:${PATH} ./pants goal ...
</pre></div>
<p>If you sometimes need to compile some code in Java 6 and sometimes Java
7, you can use a command-line arg to specify Java version:</p>
<div class="codehilite"><pre>--compile-javac-args='-target 7 -source 7'
</pre></div>
<p><em>BUT</em> beware: if you switch between Java versions, Pants doesn't realize
when it needs to rebuild. If you build with version 7, change some code,
then build with version 6, java 6 will try to understand java
7-generated classfiles and fail. Thus, if you've been building with one
Java version and are switching to another, you probably need to:</p>
<div class="codehilite"><pre>./pants goal clean-all
</pre></div>
<p>so that the next build starts from scratch.</p>
<p><a id="jvm_bundles" xmark="jvm_bundles"></a></p>
<table class="h-plus-pilcrow"><tbody><tr><td><h2 id="bundles-deploy-able-runnable-file-trees">Bundles: Deploy-able Runnable File Trees</h2></td><td><div class="pilcrow-div"><a class="pilcrow-link" href="#bundles-deploy-able-runnable-file-trees">¶</a></div></td></tr></tbody></table>
<p>You can enjoy your web service on your development machine's
<code>localhost</code>, but to let other people enjoy it, you probably want to copy
it to a server machine. With Pants, the easiest way to do this is to
create a <em>bundle</em>: a directory tree of <code>.jar</code> and helper files.</p>
<p>Our "hello world" sample application needs a configuration file to run
correctly. (You can try to run without the configuration file, but the
program crashes immediately.) We define a <code>jvm_app</code> that represents a
runnable binary and "bundles" of extra files:</p>
<p>
<pre>
jvm_app(name='main',
  basename = 'hello-example',
  dependencies = [
    ':main-bin'
  ],
  bundles = [
    bundle(relative_to='config').add(globs('config/*'))
  ]
)
</pre>
</p>
<p>Here, we keep the extra files in a subdirectory, <code>config/</code> so that they
don't clutter up this directory. (In this simple example, there's just
one file, so there isn't actually much clutter.) By using the
<a href="build_dictionary.html#bdict_bundle" xref="bdict_bundle">bundle</a>'s
<code>relative_to</code> parameter, we "strip off" that
subdirectory; in the generated bundle, these extra files will be in the
top directory.</p>
<p>(If you want to set up a tree of static files but don't need it to be
runnable, you can define a <code>jvm_app</code> target with bundles (and/or
resources) but whose <code>jvm_binary</code> has no source or main; the resulting
bundle will have the files you want (along with a couple of
not-so-useful stub <code>.jar</code> files).)</p>
<p><strong>Generating a Bundle</strong></p>
<p>Invoke <code>./pants goal bundle</code> on a JVM app or JVM binary target:</p>
<div class="codehilite"><pre>./pants goal bundle examples/src/java/com/pants/examples/hello/main:main
</pre></div>
<p><strong>Contents of a Bundle</strong></p>
<p>The generated bundle is basically a directory tree containing <code>.jar</code>s
and extra files. The <code>.jar</code> in the top-level directory has a manifest so
you can run it with <code>java -jar</code>:</p>
<div class="codehilite"><pre>$ cd dist/main-bundle/
$ java -jar main-bin.jar
16:52:11 INFO : Hello, world!
</pre></div>
<p>The "bundle" is basically a tree of files:</p>
<div class="codehilite"><pre>$ cd dist/main-bundle/
$ find .
.
./libs
./libs/javax.activation-activation-1.1.jar
./libs/javax.mail-mail-1.4.jar
./libs/log4j-log4j-1.2.15.jar
./log4j.properties
./main-bin.jar
$ jar -tf main-bin.jar
com/
com/pants/
com/pants/examples/
com/pants/examples/hello/
com/pants/examples/hello/greet/
com/pants/examples/hello/greet/Greeting.class
com/pants/examples/hello/main/
com/pants/examples/hello/main/HelloMain.class
META-INF/
META-INF/MANIFEST.MF
</pre></div>
<p>That <code>log4j.properties</code> file came from the <code>bundles=</code> parameter. The
<code>libs/</code> directory contains 3rdparty jars. The jar in the top directory
contains code compiled for this target.</p>
<p><strong>Deploying a Bundle</strong></p>
<p>Instead of just creating a directory tree, you can pass
<code>--bundle-archive</code> to <code>./pants goal bundle</code> to generate an archive file
(a zipped tarfile or some other format) instead. You can copy the
archive somewhere, then unpack it on the destination machine. If there
are some "standard jars" that are already on the destination machine,
you might want to exclude them from the archive.</p>
</body>
<!-- main content end -->

<div class="generated">
Generated by <a href="http://pantsbuild.github.io/docs.html">publish_docs</a>
dist/markdown/html/examples/src/java/com/pants/examples/readme.html 2014-10-17T11:16:07.253750
</div>

</div> <!-- end of mainflow -->

<nav class="bignav">
  <div class="bignav-logo">
    <a href="index.html">
      <img src="logo.ico" alt="[pantsbuild logo]">
    </a>
  </div>
  <form class="search" action="https://www.google.com/search">
  <input name="as_q" class="query">
  <input name="as_sitesearch" value="pantsbuild.github.io" type="hidden">
  <input value="Search" type=submit class="button">
  </form>

<div class="site-toc">
<ul>
<li class="toc-h1 toc-here">
JVM Projects with Pants
</li>
<li class="toc-h1 ">
<a href="python-readme.html">Python Projects with Pants</a>
</li>
<li class="toc-h2 ">
<a href="python_old.html">Using Pants for Python development, 2014 and Earlier</a>
</li>
<li class="toc-h1 ">
<a href="build_files.html">BUILD files</a>
</li>
<li class="toc-h1 ">
<a href="publish.html">Publishing Artifacts</a>
</li>
<li class="toc-h1 ">
<a href="build_dictionary.html">Pants BUILD Dictionary</a>
</li>
<li class="toc-h1 ">
<a href="goals_reference.html">Pants Goals Reference</a>
</li>
</ul>
</div>
</nav>

<div class="ci-status">
<a href="https://travis-ci.org/pantsbuild/pants">
<img src="https://travis-ci.org/pantsbuild/pants.png?branch=master"
     alt="Are the tests passing?" title="Are the tests passing?"></a><br>
<a href="https://coveralls.io/r/pantsbuild/pants?branch=master">
<img src="https://coveralls.io/repos/pantsbuild/pants/badge.png?branch=master"
     alt="Test Coverage Status" title="Test Coverage Status"></a>
</div>

</body>
</html>

